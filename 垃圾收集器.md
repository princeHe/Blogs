# **垃圾收集器**

## 判定对象的存活状态  

### 1.引用计数算法（不是jvm虚拟机使用的）
* 一个对象每当有一个地方引用它时，计数器加一；每当一个引用失效，计数器减一；当计数器为0的时候就代表对象是非存活状态。

### 2.可达性分析算法（jvm虚拟机使用的判定对象存活状态的方法）
* 基本思路：通过一系列的称为“GC Roots”的对象作为起始节点，从这些节点开始向下搜索，搜索走过的路径成为引用链（Reference Chain),当一个对象到达GC Roots没有任何一个引用链时（即GC Roots到这个对象不可达），就说明这个对象是非存活状态的。  
java中可以作为GC Roots的对象包括下面几种：
    * 虚拟机栈（栈帧中的本地变量表）中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中JNI（Native方法）引用的对象

### 3.关于引用
* JDK1.2以前，java中引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。
* JDK1.2以后，java对引用的概念进行了扩充，将引用分为了*强引用*，*软引用*，*弱引用*，*虚引用*四种，这四种强度依次减弱。
>* 强引用是只要引用存在就永远不会被垃圾收集器回收的对象
>* 软引用是描述一些有用但并非必须的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围进行二次回收，如果这次回收后还是没有足够的内存，才会抛出内存溢出异常
>* 弱引用也是用来描述非必须对象的，它的强度比软引用更弱一些，被弱引用关联的对象只能存活到下一次垃圾收集发生之前。
>* 虚引用是最弱的一种引用关系，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 4.生存还是死亡
* 在可达性分析算法中宣告一个对象的死亡，需要至少经历两次标记过程：如果对象在进行可达性分析后没有发现与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。  
如果这个对象被判定为有必要执行finalize()方法，那么这个对象会放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它（触发这个方法，并不承诺会等待它运行结束，防止内存回收系统缓慢、死循环甚至崩溃）。finalize()方法是对象逃离死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中拯救自己，只需要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移除出“即将回收”的集合，否则它基本上就真的被回收了。