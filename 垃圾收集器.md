# **垃圾收集器**

## 判定对象的存活状态  

### 1.引用计数算法（不是jvm虚拟机使用的）
* 一个对象每当有一个地方引用它时，计数器加一；每当一个引用失效，计数器减一；当计数器为0的时候就代表对象是非存活状态。

### 2.可达性分析算法（jvm虚拟机使用的判定对象存活状态的方法）

* 基本思路：通过一系列的称为“GC Roots”的对象作为起始节点，从这些节点开始向下搜索，搜索走过的路径成为引用链（Reference Chain),当一个对象到达GC Roots没有任何一个引用链时（即GC Roots到这个对象不可达），就说明这个对象是非存活状态的。  
java中可以作为GC Roots的对象包括下面几种：
    * 虚拟机栈（栈帧中的本地变量表）中引用的对象
    * 方法区中类静态属性引用的对象
    * 方法区中常量引用的对象
    * 本地方法栈中JNI（Native方法）引用的对象

### 3.关于引用

* JDK1.2以前，java中引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。
* JDK1.2以后，java对引用的概念进行了扩充，将引用分为了*强引用*，*软引用*，*弱引用*，*虚引用*四种，这四种强度依次减弱。
>* 强引用是只要引用存在就永远不会被垃圾收集器回收的对象
>* 软引用是描述一些有用但并非必须的对象，在系统将要发生内存溢出之前，会把这些对象列进回收范围进行二次回收，如果这次回收后还是没有足够的内存，才会抛出内存溢出异常
>* 弱引用也是用来描述非必须对象的，它的强度比软引用更弱一些，被弱引用关联的对象只能存活到下一次垃圾收集发生之前。
>* 虚引用是最弱的一种引用关系，为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

### 4.生存还是死亡
* 在可达性分析算法中宣告一个对象的死亡，需要至少经历两次标记过程：如果对象在进行可达性分析后没有发现与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。  
如果这个对象被判定为有必要执行finalize()方法，那么这个对象会放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它（触发这个方法，并不承诺会等待它运行结束，防止内存回收系统缓慢、死循环甚至崩溃）。finalize()方法是对象逃离死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中拯救自己，只需要重新与引用链上的任何一个对象建立关联即可，那在第二次标记时它将被移除出“即将回收”的集合，否则它基本上就真的被回收了。

## 垃圾收集算法 

### 1.标记-清除算法
* 它是最基础的收集算法，算法分为“标记”和“清除”两个阶段，首先使用可达性分析算法标记出需要回收的对象，在标记完成后统一回收。它有两个主要的不足：一是效率问题，标记和清除两个过程的效率都不高，另一个是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片过多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。

### 2.复制算法
* 复制算法是将内存按容量分为大小相等的两块，每次只使用其中的一块，当一块的内存使用完了，就将还存活着的对象复制到另一块上去，然后再把已使用过的内存空间一次性清理掉，这样每次都是对整个半区进行内存回收。内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，简单高效。缺点就是将内存缩小为了原来的一半，空间损失过大。  
  现代商业虚拟机针对新生代都是采用复制算法，研究表明新生代中98%的对象都是朝生夕死的所以并不需要1:1的比例来划分内存空间，而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间；每次使用Eden和一块Survivor。回收时将Eden和Survivor中还存活的对象复制到另一块Survivor上，最后清理掉Eden和刚才已经使用过的Survivor。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，我们没有办法保证每次回收之后不到10%的对象存活，所以需要依赖其他内存（老年代）进行分配担保。

### 3.标记-整理算法
* 复制收集算法在对象存活率较高时就要进行较多的复制操作，影响效率。老年代一般不能直接选用这种算法。  
  根据老年代的特点，有人提出了*“标记-整理”*算法，“标记”过程仍然与“*标记-清除*”算法一样，但后续不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
 ### 4.分代收集算法
 * 分代收集算法是根据对象存活周期的不同，将内存划分为几块，分别采取不同的收集算法进行收集。
