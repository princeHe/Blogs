# **java虚拟机的运行时数据区域**

## 1.程序计数器
* 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器来选取下一条需要执行的字节码指令，它是一块线程私有内存，此内存是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的内存区域。
## 2.虚拟机栈
* 虚拟机栈也是线程私有的，虚拟机栈描述的是java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（StackFrame）用于存储*局部变量表*、*操作数栈*、*动态链接*、*方法出口*等信息，每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  
局部变量表存放了编译期可知的各种基本数据类型（boolean,byte,short,int,long,float,double,char）、对象引用（reference类型，非对象，而是一个指向对象起始地址的引用指针，或者是指向一个代表对象的句柄等）和returnAddress类型（指向了一条字节码指令的地址）。  
其中64位长度的long和double类型的数据会占用两个局部变量空间（Slot）其余的数据类型占用一个。局部变量表所需的内存空间在编译期完成分配，进入方法时，需要在栈帧中分配多大的局部变量空间是完全确定的，方法运行期间不会改变局部变量表的大小。  
java虚拟机规范对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机多允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。
## 3.本地方法栈
* 本地方法栈与虚拟机栈的作用很相似，区别就是虚拟机栈为虚拟机执行字节码服务，而本地方法栈为虚拟机使用到的Native方法服务。
## 4.方法区
* 方法区是各线程共享的内存区域，用于存储已被虚拟机加载的*类信息*、*常量*、*静态变量*、*即时编译器编译后的代码等数据*，虚拟机规范中描述其为堆的一个逻辑部分。
## 5.堆
* 堆是java虚拟机所管理的内存中最大的一块，他也是被所有线程共享的一块内存区域，在虚拟机启动时创建，它用于存放对象实例。  
堆是垃圾收集管理的主要区域，所以也被称为GC堆。由于现在垃圾收集器基本都采用分代收集算法，因此堆可以分为新生代和老年代。线程共享的堆可以划分成多个线程私有的分配缓冲区。  
堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。堆可能抛出OutOfMemory异常。
